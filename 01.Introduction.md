# Introduction

I find functional programming exhilarating because it helps me produce music that I would not otherwise have been able to make. Music like:

[]()

or

[]()

or

[]()

All three of these examples would be tedious, and in some cases impossible, using a traditional DAW like Logic, a tool like Live, a visual coding language like Max or a procedural language like JavaScript. I believe that millions of brilliant voices are not realizing their full potential because their digital tooling enforces paradigms that ultimately stifle creativity more than they enable it. Functional programming provides musicians with a new set of tools and ideas with which they can make radically new work.

## Composition

The word _compose_ is fundamental in music and in functional programming. This no accident. In music, when we compose, we build complex structures from simple elements on many different timescales. In functional programming, when we compose, we combine together data and functions on many different scales of a program. It's not surprising that many musicians discover programming through its functional dialects, and many functional programmers are avid musicians.

I have been working with music and with functional programming (which I'll abbreviate as FP in this guide) for over twenty years, and many of my epiphanies about one domain have been linked to discoveries the other. Modeling music as a stream of notes in time led me to work on functional reactive programming, which is concerned with composing together streams of discrete and continuous events. Discovering existential types in functional programming led me to build rich, live-coding musical experiences in the browser. When I find myself staring down a blank canvas in one domain, I dip into the other for inspiration and often find something fresh and new.

Musicians and functional programmers are often avid lifelong learners. The are also passionate _re_-learners. The basic concepts of both music and FP can be squeezed onto a single A4 piece of paper, but a deep understanding of these concepts requires continuously rediscovering, reinventing and ultimately transcending them. In the realm of music, I'm always re-learning what a groove is, and on each pass, I'm able to land on new grooves and beats that I would have never imagined before. In functional programming, I'm always re-learning what a monoid is, and I'm continuously amazed by the multitude of patterns that are a monoid when boiled down to their essence.

This text is meant for those who would like to learn or re-learn about music through functional programming and vice versa. It starts from basic principles in both, taking the reader and listener on a journey through emotional and intellectual landscapes that never cease to befuddle, surprise, provoke, and delight.

During this journey, we will frequently make use of our fingers to type or edit code and our ears to listen. The basic interface, which you will see time and time again, is the editor pane. Go on, click **Start Audio** below and listen to the musical example.

![]()

In the example above, `c4` is a pitch representing middle-c on a piano. Try changing it to `d4`, then play it again and listen to the difference. What about `aFlat4`? `c5`?

In just a few lines of code, we can already arrive at rich and expressive musical textures.

![]()

If you've never worked with functional programming or with music before, don't worry. You just listened to an [isorhythmic pattern](https://en.wikipedia.org/wiki/Isorhythm) with a _talea_ and _color_, and the code in the example uses a several powerful abstractions, including the [functor](https://pursuit.purescript.org/packages/purescript-prelude/5.0.1/docs/Data.Functor#t:Functor), the [profunctor](https://pursuit.purescript.org/packages/purescript-profunctor/5.0.0/docs/Data.Profunctor#t:Profunctor), and the [semigroupoid](https://pursuit.purescript.org/packages/purescript-prelude/5.0.1/docs/Control.Semigroupoid#t:Semigroupoid). We'll learn about what all these concepts mean and revisit some of them multiple times. The important thing to know is that one domain will always reinforce the other, stimulating our creativity and leading us to new territory as both musicians and programmers.
