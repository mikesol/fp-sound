"use strict";(self.webpackChunksoundly_functional=self.webpackChunksoundly_functional||[]).push([[1455],{29866:function(e,t,n){n.r(t),n.d(t,{_frontmatter:function(){return l},default:function(){return c}});var a=n(63366),o=(n(67294),n(64983)),i=n(23742),r=n(10045),s=n(92504),p=["components"],l={},m={_frontmatter:l};function c(e){var t=e.components,n=(0,a.Z)(e,p);return(0,o.kt)("wrapper",Object.assign({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",null,"The note and the function"),(0,o.kt)("p",null,"We'll start our journey with a single note. This note will be produced by a sine-wave oscillator. When you click ",(0,o.kt)("strong",{parentName:"p"},"Start Audio"),", the computer will send instructions to your loudspeaker or headphones to oscillate back and forth in sinusoidal motion. This creates wave-like variations in air pressure that propagate all the way to your ear. Middle-C, the note below, will cause the air around you to oscillate 264 times a second. This is, of course, really fast - far too fast to perceive each individual oscillation. Our ear clumps the oscillations together as a pattern, and we hear it as the note middle-C. You can also check out this ",(0,o.kt)("a",{parentName:"p",href:"https://pudding.cool/2018/02/waveforms/"},"amazing interactive article about how sound works"),"."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"todo: insert example")),(0,o.kt)("p",null,"Our single note is accompanied by a short program: the minimal amount of information we need to play back the note. The program starts by defining a ",(0,o.kt)("strong",{parentName:"p"},"module"),". By calling this module ",(0,o.kt)("inlineCode",{parentName:"p"},"Main"),", we're telling the compiler that this is where the main action of our program resides. This is followed by a series of ",(0,o.kt)("inlineCode",{parentName:"p"},"import"),' statements declaring what types and terms we\'ll use from other libraries (I\'ll define "type" and "term" below). Lastly, the actual program called ',(0,o.kt)("inlineCode",{parentName:"p"},"main")," exists on two levels: the type-level (its type is ",(0,o.kt)("inlineCode",{parentName:"p"},"Effect Unit"),") and on the term-level (its terms are ",(0,o.kt)("inlineCode",{parentName:"p"},"play")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"c4"),"). This distinction between, and eventually interplay of, types and terms will be crucial to our reasoning about music and functional programs."),(0,o.kt)("h2",null,"Types and terms"),(0,o.kt)("p",null,"Functional programs contain two basic units of composition: ",(0,o.kt)("em",{parentName:"p"},"types")," and ",(0,o.kt)("em",{parentName:"p"},"terms"),". These types and terms are the props used in a play staring three core protagonists: you, a compiler, and a computer. A ",(0,o.kt)("em",{parentName:"p"},"term")," points to some chunk of memory on a computer that stores an opaque series of bytes. We give the term a name like ",(0,o.kt)("inlineCode",{parentName:"p"},"c4")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"play")," to indicate to other readers what it ",(0,o.kt)("em",{parentName:"p"},"is")," or ",(0,o.kt)("em",{parentName:"p"},"does"),". A ",(0,o.kt)("inlineCode",{parentName:"p"},"type")," is an assertion to the compiler about how a term can be used in a program. Types have names like ",(0,o.kt)("inlineCode",{parentName:"p"},"Effect Unit"),". When the compiler receives an assertion in the form of a type, it can either accept the assertion, reject it, or punt until it receives more information. In our program above, the compiler ",(0,o.kt)("em",{parentName:"p"},"accepts")," the assertion that ",(0,o.kt)("inlineCode",{parentName:"p"},"play c4")," has the type ",(0,o.kt)("inlineCode",{parentName:"p"},"Effect Unit"),". When all the assertions in a program are accepted, we say a program compiles, and the compiler sends the program off to the computer to do something interesting like render it to your screen, play it through your loudspeakers, or save it for a rainy day."),(0,o.kt)("p",null,"Let's revisit the program above:"),(0,o.kt)(r.J,{player:s.main,code:i.l,mdxType:"Player"}),(0,o.kt)("p",null,"It contains one type assertion - that ",(0,o.kt)("inlineCode",{parentName:"p"},"main")," is ",(0,o.kt)("inlineCode",{parentName:"p"},"Effect Unit")," - and three terms:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"main"),", whose type is asserted to be ",(0,o.kt)("inlineCode",{parentName:"li"},"Effect Unit"),";"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"play"),", whose type is ",(0,o.kt)("inlineCode",{parentName:"li"},"Function Pitch (Effect Unit)"),"; and"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"c4"),", whose type is ",(0,o.kt)("inlineCode",{parentName:"li"},"Pitch"),".")),(0,o.kt)("p",null,"Often times, when talking about functions, we'll use an infix notation of a right-pointing arrow ",(0,o.kt)("inlineCode",{parentName:"p"},"->"),". So, ",(0,o.kt)("inlineCode",{parentName:"p"},"play")," can be rewritten as ",(0,o.kt)("inlineCode",{parentName:"p"},"Pitch -> Effect Unit"),"."),(0,o.kt)("p",null,"When the compiler compiles the program, it treats every function as an ",(0,o.kt)("em",{parentName:"p"},"if/then")," proposition and makes sure that we've provided enough evidence to prove this proposition. In the case above, ",(0,o.kt)("inlineCode",{parentName:"p"},"play"),' is a proposition saying "If you give me a ',(0,o.kt)("inlineCode",{parentName:"p"},"Pitch"),", I'll give you a term of type ",(0,o.kt)("inlineCode",{parentName:"p"},"Effect Unit"),'". In the program, ',(0,o.kt)("inlineCode",{parentName:"p"},"c4")," is ",(0,o.kt)("em",{parentName:"p"},"evidence")," to play (we can also call it an argument to ",(0,o.kt)("inlineCode",{parentName:"p"},"play")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"play"),"'s input). Evidence to propositions, or equivalently arguments to functions, act like keys to a lock. The term ",(0,o.kt)("inlineCode",{parentName:"p"},"c4")," of type ",(0,o.kt)("inlineCode",{parentName:"p"},"Pitch")," unlocks the proposition ",(0,o.kt)("inlineCode",{parentName:"p"},"Pitch -> Effect Unit"),", producing an ",(0,o.kt)("inlineCode",{parentName:"p"},"Effect Unit"),". Because we have annotated our program ",(0,o.kt)("inlineCode",{parentName:"p"},"main")," as ",(0,o.kt)("inlineCode",{parentName:"p"},"Effect Unit"),", the compiler accepts the program, sends it to your loudspeaker and plays a note. w00t!"),(0,o.kt)("p",null,"The fluidity with which one can switch between the language of logic (proving a proposition with evidence) and programming (applying to a function an argument) is called the Curry-Howard correspondence. Informally, it teaches us that programs are proofs and vice versa. Granted, music is a highly ",(0,o.kt)("em",{parentName:"p"},"illogical")," endeavor, so this type of rigorous formalism may seem antithetical to the high degree of fantasy present in music composition and listening. The point of types here is to provide a set of constraints proving that what you're building has the best chance to work as expected and produce the sound you're aiming to produce."),(0,o.kt)("h2",null,"Our first composition(s)"),(0,o.kt)("p",null,"In this example above, we listened to our first note ",(0,o.kt)("inlineCode",{parentName:"p"},"c4")," by applying the function ",(0,o.kt)("inlineCode",{parentName:"p"},"play")," to it. Let's compose together some more functions to see how far we can push that note."),(0,o.kt)("h2",null,"The more the merrier"),(0,o.kt)("p",null,"In music, when you compose together several notes, the outcome is often indistinguishable from a single note. Listen to the example below."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:""})),(0,o.kt)("p",null,"This example is composed of 10 different notes, but they blend together in a single tone to the point that our ear has difficulty distinguishing between its constituent notes. From a functional programming standpoint, we compose the notes together with the function ",(0,o.kt)("inlineCode",{parentName:"p"},"<>"),", which is also called ",(0,o.kt)("inlineCode",{parentName:"p"},"append"),".  We'll dive into what a ",(0,o.kt)("inlineCode",{parentName:"p"},"append")," means in a bit, but one cool thing we can explore already is decomposing the note we hear into its constituent parts and letting them sum back up again. This creates a really interesting effect:"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:""})),(0,o.kt)("p",null,"This effect can be quite expressive. In the example below, try moving your mouse (or finger for mobile users) over the screen as you listen."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:""})),(0,o.kt)("p",null,"With several devices at different pitches, you have a tiny orchestra!"),(0,o.kt)("h2",null,"Conclusion"),(0,o.kt)("p",null,"In this section, we learned about how a loudspeaker, oscillating back and forth in sinusoidal motion, produces a single note. We saw how we can compose together functions to modulate the pitch and amplitude of that note, and we saw how to compose together several notes into one uber-note that decomposes and recomposes as we listen to it. With these techniques, we can make beautiful little instruments like the one below, the source code of which can be found ",(0,o.kt)("a",{parentName:"p",href:""},"here"),". I hope you enjoy playing it, and I'll see you in the next section on ",(0,o.kt)("a",{parentName:"p",href:""},"rhythm and functors"),"."))}c.isMDXComponent=!0},63366:function(e,t,n){function a(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}n.d(t,{Z:function(){return a}})}}]);
//# sourceMappingURL=component---src-pages-02-the-note-and-the-function-mdx-5c44881b5fe3cbcd43f1.js.map