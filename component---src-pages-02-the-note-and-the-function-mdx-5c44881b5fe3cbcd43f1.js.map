{"version":3,"file":"component---src-pages-02-the-note-and-the-function-mdx-5c44881b5fe3cbcd43f1.js","mappings":"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","sources":["webpack://soundly-functional/./src/pages/02.TheNoteAndTheFunction.mdx","webpack://soundly-functional/./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js"],"sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\n\nimport { simple } from \"../examples/02.js\";\nimport { Player } from \"../components/player\";\nimport { main as eNote } from \"../../output/FPSound.C02.ENote/\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\";\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n    <h1>{`The note and the function`}</h1>\n    <p>{`We'll start our journey with a single note. This note will be produced by a sine-wave oscillator. When you click `}<strong parentName=\"p\">{`Start Audio`}</strong>{`, the computer will send instructions to your loudspeaker or headphones to oscillate back and forth in sinusoidal motion. This creates wave-like variations in air pressure that propagate all the way to your ear. Middle-C, the note below, will cause the air around you to oscillate 264 times a second. This is, of course, really fast - far too fast to perceive each individual oscillation. Our ear clumps the oscillations together as a pattern, and we hear it as the note middle-C. You can also check out this `}<a parentName=\"p\" {...{\n        \"href\": \"https://pudding.cool/2018/02/waveforms/\"\n      }}>{`amazing interactive article about how sound works`}</a>{`.`}</p>\n    <blockquote>\n      <p parentName=\"blockquote\">{`todo: insert example`}</p>\n    </blockquote>\n    <p>{`Our single note is accompanied by a short program: the minimal amount of information we need to play back the note. The program starts by defining a `}<strong parentName=\"p\">{`module`}</strong>{`. By calling this module `}<inlineCode parentName=\"p\">{`Main`}</inlineCode>{`, we're telling the compiler that this is where the main action of our program resides. This is followed by a series of `}<inlineCode parentName=\"p\">{`import`}</inlineCode>{` statements declaring what types and terms we'll use from other libraries (I'll define \"type\" and \"term\" below). Lastly, the actual program called `}<inlineCode parentName=\"p\">{`main`}</inlineCode>{` exists on two levels: the type-level (its type is `}<inlineCode parentName=\"p\">{`Effect Unit`}</inlineCode>{`) and on the term-level (its terms are `}<inlineCode parentName=\"p\">{`play`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`c4`}</inlineCode>{`). This distinction between, and eventually interplay of, types and terms will be crucial to our reasoning about music and functional programs.`}</p>\n    <h2>{`Types and terms`}</h2>\n    <p>{`Functional programs contain two basic units of composition: `}<em parentName=\"p\">{`types`}</em>{` and `}<em parentName=\"p\">{`terms`}</em>{`. These types and terms are the props used in a play staring three core protagonists: you, a compiler, and a computer. A `}<em parentName=\"p\">{`term`}</em>{` points to some chunk of memory on a computer that stores an opaque series of bytes. We give the term a name like `}<inlineCode parentName=\"p\">{`c4`}</inlineCode>{` or `}<inlineCode parentName=\"p\">{`play`}</inlineCode>{` to indicate to other readers what it `}<em parentName=\"p\">{`is`}</em>{` or `}<em parentName=\"p\">{`does`}</em>{`. A `}<inlineCode parentName=\"p\">{`type`}</inlineCode>{` is an assertion to the compiler about how a term can be used in a program. Types have names like `}<inlineCode parentName=\"p\">{`Effect Unit`}</inlineCode>{`. When the compiler receives an assertion in the form of a type, it can either accept the assertion, reject it, or punt until it receives more information. In our program above, the compiler `}<em parentName=\"p\">{`accepts`}</em>{` the assertion that `}<inlineCode parentName=\"p\">{`play c4`}</inlineCode>{` has the type `}<inlineCode parentName=\"p\">{`Effect Unit`}</inlineCode>{`. When all the assertions in a program are accepted, we say a program compiles, and the compiler sends the program off to the computer to do something interesting like render it to your screen, play it through your loudspeakers, or save it for a rainy day.`}</p>\n    <p>{`Let's revisit the program above:`}</p>\n    <Player player={eNote} code={simple} mdxType=\"Player\" />\n    <p>{`It contains one type assertion - that `}<inlineCode parentName=\"p\">{`main`}</inlineCode>{` is `}<inlineCode parentName=\"p\">{`Effect Unit`}</inlineCode>{` - and three terms:`}</p>\n    <ul>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`main`}</inlineCode>{`, whose type is asserted to be `}<inlineCode parentName=\"li\">{`Effect Unit`}</inlineCode>{`;`}</li>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`play`}</inlineCode>{`, whose type is `}<inlineCode parentName=\"li\">{`Function Pitch (Effect Unit)`}</inlineCode>{`; and`}</li>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`c4`}</inlineCode>{`, whose type is `}<inlineCode parentName=\"li\">{`Pitch`}</inlineCode>{`.`}</li>\n    </ul>\n    <p>{`Often times, when talking about functions, we'll use an infix notation of a right-pointing arrow `}<inlineCode parentName=\"p\">{`->`}</inlineCode>{`. So, `}<inlineCode parentName=\"p\">{`play`}</inlineCode>{` can be rewritten as `}<inlineCode parentName=\"p\">{`Pitch -> Effect Unit`}</inlineCode>{`.`}</p>\n    <p>{`When the compiler compiles the program, it treats every function as an `}<em parentName=\"p\">{`if/then`}</em>{` proposition and makes sure that we've provided enough evidence to prove this proposition. In the case above, `}<inlineCode parentName=\"p\">{`play`}</inlineCode>{` is a proposition saying \"If you give me a `}<inlineCode parentName=\"p\">{`Pitch`}</inlineCode>{`, I'll give you a term of type `}<inlineCode parentName=\"p\">{`Effect Unit`}</inlineCode>{`\". In the program, `}<inlineCode parentName=\"p\">{`c4`}</inlineCode>{` is `}<em parentName=\"p\">{`evidence`}</em>{` to play (we can also call it an argument to `}<inlineCode parentName=\"p\">{`play`}</inlineCode>{` or `}<inlineCode parentName=\"p\">{`play`}</inlineCode>{`'s input). Evidence to propositions, or equivalently arguments to functions, act like keys to a lock. The term `}<inlineCode parentName=\"p\">{`c4`}</inlineCode>{` of type `}<inlineCode parentName=\"p\">{`Pitch`}</inlineCode>{` unlocks the proposition `}<inlineCode parentName=\"p\">{`Pitch -> Effect Unit`}</inlineCode>{`, producing an `}<inlineCode parentName=\"p\">{`Effect Unit`}</inlineCode>{`. Because we have annotated our program `}<inlineCode parentName=\"p\">{`main`}</inlineCode>{` as `}<inlineCode parentName=\"p\">{`Effect Unit`}</inlineCode>{`, the compiler accepts the program, sends it to your loudspeaker and plays a note. w00t!`}</p>\n    <p>{`The fluidity with which one can switch between the language of logic (proving a proposition with evidence) and programming (applying to a function an argument) is called the Curry-Howard correspondence. Informally, it teaches us that programs are proofs and vice versa. Granted, music is a highly `}<em parentName=\"p\">{`illogical`}</em>{` endeavor, so this type of rigorous formalism may seem antithetical to the high degree of fantasy present in music composition and listening. The point of types here is to provide a set of constraints proving that what you're building has the best chance to work as expected and produce the sound you're aiming to produce.`}</p>\n    <h2>{`Our first composition(s)`}</h2>\n    <p>{`In this example above, we listened to our first note `}<inlineCode parentName=\"p\">{`c4`}</inlineCode>{` by applying the function `}<inlineCode parentName=\"p\">{`play`}</inlineCode>{` to it. Let's compose together some more functions to see how far we can push that note.`}</p>\n    <h2>{`The more the merrier`}</h2>\n    <p>{`In music, when you compose together several notes, the outcome is often indistinguishable from a single note. Listen to the example below.`}</p>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"\"\n      }}></a></p>\n    <p>{`This example is composed of 10 different notes, but they blend together in a single tone to the point that our ear has difficulty distinguishing between its constituent notes. From a functional programming standpoint, we compose the notes together with the function `}<inlineCode parentName=\"p\">{`<>`}</inlineCode>{`, which is also called `}<inlineCode parentName=\"p\">{`append`}</inlineCode>{`.  We'll dive into what a `}<inlineCode parentName=\"p\">{`append`}</inlineCode>{` means in a bit, but one cool thing we can explore already is decomposing the note we hear into its constituent parts and letting them sum back up again. This creates a really interesting effect:`}</p>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"\"\n      }}></a></p>\n    <p>{`This effect can be quite expressive. In the example below, try moving your mouse (or finger for mobile users) over the screen as you listen.`}</p>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"\"\n      }}></a></p>\n    <p>{`With several devices at different pitches, you have a tiny orchestra!`}</p>\n    <h2>{`Conclusion`}</h2>\n    <p>{`In this section, we learned about how a loudspeaker, oscillating back and forth in sinusoidal motion, produces a single note. We saw how we can compose together functions to modulate the pitch and amplitude of that note, and we saw how to compose together several notes into one uber-note that decomposes and recomposes as we listen to it. With these techniques, we can make beautiful little instruments like the one below, the source code of which can be found `}<a parentName=\"p\" {...{\n        \"href\": \"\"\n      }}>{`here`}</a>{`. I hope you enjoy playing it, and I'll see you in the next section on `}<a parentName=\"p\" {...{\n        \"href\": \"\"\n      }}>{`rhythm and functors`}</a>{`.`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      ","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}"],"names":["_frontmatter","layoutProps","MDXContent","components","props","mdxType","parentName","player","eNote","code","simple","isMDXComponent","_objectWithoutPropertiesLoose","source","excluded","key","i","target","sourceKeys","Object","keys","length","indexOf"],"sourceRoot":""}