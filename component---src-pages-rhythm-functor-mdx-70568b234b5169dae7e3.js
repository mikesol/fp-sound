"use strict";(self.webpackChunksoundly_functional=self.webpackChunksoundly_functional||[]).push([[997],{70475:function(e,t,a){a.r(t),a.d(t,{_frontmatter:function(){return j},default:function(){return M}});var n=a(63366),o=(a(67294),a(64983)),i=a(407),r=a(65216),l=a(37086),p=a(74831),s=a(52800),m=a(7930),h=a(83798),c=a(36469),d=a(76028),u=a(39652),k=a(54593),f=a(13112),y=a(25227),g=a(52528),b=a(15597),N=a(9247),w=a(48424),C=a(65889),v=a(35293),x=a(58807),T=a(26017),P=a(78372),I=a(50011),A=a(67477),B=a(714),J=a(46094),S=["components"],j={},F={_frontmatter:j};function M(e){var t=e.components,a=(0,n.Z)(e,S);return(0,o.kt)("wrapper",Object.assign({},F,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",null,"The rhythm and the functor"),(0,o.kt)("p",null,"Rhythms transport humans and functors transport categories. By the end of this post, I want you to have a working understanding of what functors are with respect to categories and what the rhythms are with respect to music. Even more importantly, I want you to feel the rhythm of functors and grok the functorality of rhythm."),(0,o.kt)(i.J,{player:m.main,code:s,mdxType:"Player"}),(0,o.kt)("h2",null,"Rhythm"),(0,o.kt)("p",null,"A rhythm is a series of unaccented and accented moments in time. The accents are demarcated by changes in metric placement, volume, timbre and harmony."),(0,o.kt)(i.J,{player:c.main,code:h,mdxType:"Player"}),(0,o.kt)("p",null,"Its the delicate mix of symmetry and asymmetry in rhythm that deeply moves us. Some of this is certainly culturally delimited, stemming from the use of certain instruments or voices or pitch languages."),(0,o.kt)(i.J,{player:u.main,code:d,mdxType:"Player"}),(0,o.kt)("p",null,"Other aspects of rhythm's power feels more intrinsic. When we catch ourselves being taken aback by the rhythm of a forest or of a machine, we struggle to explain why, and that's of course ok."),(0,o.kt)(i.J,{player:f.main,code:k,mdxType:"Player"}),(0,o.kt)("p",null,"Rhythm has been the subject of a rich hermeneutic tradition throughout the ages — Plato compared it to both an orderly life and the most intimate of personal tastes and convictions in ",(0,o.kt)("a",{parentName:"p",href:"http://classics.mit.edu/Plato/republic.4.iii.html"},"The Republic"),". The free use of mixed metaphors that liken rhythm to internal and external phenomena show both the difficulty in classifying it and the captivating power it has over us."),(0,o.kt)(i.J,{player:g.main,code:y,mdxType:"Player"}),(0,o.kt)("p",null,"Like many things in music, rhythm often exists as a conversation with the past, taking the old and creativly deforming it into something new. One of my favorite examples of this is JAY-Z's ",(0,o.kt)("em",{parentName:"p"},"Show Me What you Got"),"."),(0,o.kt)(i.J,{player:N.main,code:b,mdxType:"Player"}),(0,o.kt)("p",null,"I could go on forever about why I love this rhythm. Some reasons probably include:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The bold accents on the backbeats coupled with the relatively weak downbeats."),(0,o.kt)("li",{parentName:"ul"},"The alternation between highly regular measures and measures with a free sens of time."),(0,o.kt)("li",{parentName:"ul"},"The slow pace of the horns and sax against the drum groove and piano glissandos."),(0,o.kt)("li",{parentName:"ul"},"The very (very) laid-back backbeat on most beat-2s."),(0,o.kt)("li",{parentName:"ul"},"The rap itself, which flows in and out of the meter in really subtle ways.")),(0,o.kt)("p",null,"But at the end of the day when I'm listening to it I don't think about any of these things: I just love it. And I love to remix it!"),(0,o.kt)(i.J,{player:C.main,code:w,mdxType:"Player"}),(0,o.kt)("h2",null,"Categories"),(0,o.kt)("p",null,"In the ",(0,o.kt)("a",{parentName:"p",href:"../note-function"},"previous post"),", we explored the difference between types and terms. In PureScript and related programming languages, the sum total of all possible types and the functions between the terms that inhabit these types make up a ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Category_(mathematics)"},(0,o.kt)("em",{parentName:"a"},"category")),". In this category, types are ",(0,o.kt)("em",{parentName:"p"},"objects")," (or nodes) and functions are ",(0,o.kt)("em",{parentName:"p"},"morphisms")," (or arrows). Let's call PureScript's category ",(0,o.kt)("strong",{parentName:"p"},"Purs"),", hereafter referred to as 𝕻 for short."),(0,o.kt)("p",null,"For something to be a category, it needs to follow two rules:"),(0,o.kt)("h3",null,"Rule 1 - Identity"),(0,o.kt)("p",null,"All objects must have an identity morphism that goes from it back to it. For every type ",(0,o.kt)("inlineCode",{parentName:"p"},"a")," in 𝕻, we can construct a function ",(0,o.kt)("inlineCode",{parentName:"p"},"a -> a")," that returns the input as output."),(0,o.kt)("deckgo-highlight-code",{language:"haskell"},"\n          ",(0,o.kt)("code",{parentName:"deckgo-highlight-code",slot:"code"},"class Category c where\n  identity :: forall a. c a a\n\ninstance Category (->) where\n  identity a = a"),"\n        "),(0,o.kt)("h3",null,"Rule 2 - Composition"),(0,o.kt)("p",null,"If there exists a morphism from ",(0,o.kt)("inlineCode",{parentName:"p"},"C -> D")," and a morphism from ",(0,o.kt)("inlineCode",{parentName:"p"},"B -> C"),", there exists a morphism from ",(0,o.kt)("inlineCode",{parentName:"p"},"B -> D")," that is formed by first going from ",(0,o.kt)("inlineCode",{parentName:"p"},"B")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"C")," and then from ",(0,o.kt)("inlineCode",{parentName:"p"},"C")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"D"),". If we look at the definition of ",(0,o.kt)("a",{parentName:"p",href:"https://pursuit.purescript.org/packages/purescript-prelude/5.0.1/docs/Control.Semigroupoid#t:Semigroupoid"},"compose"),", a function we used extensively in the last section, it is ",(0,o.kt)("inlineCode",{parentName:"p"},"forall b c d. a c d -> a b c -> a b d")," where ",(0,o.kt)("inlineCode",{parentName:"p"},"a")," is an arbitrary semigroupoid (in this case, a function). So, when specialized to functions, this can be written as ",(0,o.kt)("inlineCode",{parentName:"p"},"forall b c d. (c -> d) -> (b -> c) -> (b -> d)"),"."),(0,o.kt)("p",null,"So 𝕻 is a category, and where there are categories, there are functors."),(0,o.kt)("h2",null,"Functors"),(0,o.kt)("p",null,"A ",(0,o.kt)("a",{parentName:"p",href:"https://bartoszmilewski.com/2015/01/20/functors/"},"functor")," is a mapping of objects and morphisms from one category to another category. As PureScript can't go outside of PureScript (yet!), the functors we will look at are from 𝕻 to 𝕻. Functors from a category back to itself are called ",(0,o.kt)("em",{parentName:"p"},"endo-functors"),"."),(0,o.kt)("p",null,"Any category can be described completely in terms of its morphisms, as all objects can be indexed by their identity morphism. Because of this special property of categories, functors can be described by how they map ",(0,o.kt)("em",{parentName:"p"},"morphisms")," to ",(0,o.kt)("em",{parentName:"p"},"morphisms"),". In PureScript, one way this is done is called ",(0,o.kt)("inlineCode",{parentName:"p"},"map"),"."),(0,o.kt)("deckgo-highlight-code",{language:"haskell"},"\n          ",(0,o.kt)("code",{parentName:"deckgo-highlight-code",slot:"code"},"class Functor f where\n  map :: forall a b. (a -> b) -> (f a -> f b)"),"\n        "),(0,o.kt)("p",null,"The parentheses around ",(0,o.kt)("inlineCode",{parentName:"p"},"f a -> f b")," can be dropped and it would mean the same thing, but I like them because they make it clear that we are mapping a morphism ",(0,o.kt)("inlineCode",{parentName:"p"},"a -> b")," to a ",(0,o.kt)("em",{parentName:"p"},"new")," moprhism from ",(0,o.kt)("inlineCode",{parentName:"p"},"f a -> f b"),", where both ",(0,o.kt)("inlineCode",{parentName:"p"},"f a")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"f b")," are objects somewhere else in the vast category of 𝕻. Importantly, the mapping in PureScript's ",(0,o.kt)("inlineCode",{parentName:"p"},"Functor")," class is called a ",(0,o.kt)("strong",{parentName:"p"},"covariant"),' mapping, meaning the direction of morphisms in the source category and the destination are the same (they "vary" in the same direction). Not all functors are covariant, but the most common ones in programming are, and the word "functor" is used interchangeably with "covariant functor."'),(0,o.kt)("p",null,"Some classic covariant functors include ",(0,o.kt)("inlineCode",{parentName:"p"},"Maybe"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"List"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Array"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Proxy"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Tuple a"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Either a"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Const a"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Map k"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Function a")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Identity"),". For example, the ",(0,o.kt)("inlineCode",{parentName:"p"},"Maybe")," functor transports the function ",(0,o.kt)("inlineCode",{parentName:"p"},"not :: Boolean -> Boolean")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"Maybe Boolean -> Maybe Boolean"),". Those with type variables, like ",(0,o.kt)("inlineCode",{parentName:"p"},"Tuple a"),", represent families of functors: one for every type. Meaning that ",(0,o.kt)("inlineCode",{parentName:"p"},"Tuple Int")," is a functor, ",(0,o.kt)("inlineCode",{parentName:"p"},"Tuple Boolean")," is a functor, etc. "),(0,o.kt)("h2",null,"Music + Functors"),(0,o.kt)("p",null,"As a general strategy, anytime you transport a musical entity to a new place, you can think of a functor being applied to it. Transpose a scale? There's a functor for that."),(0,o.kt)(i.J,{player:x.main,code:v,mdxType:"Player"}),(0,o.kt)("p",null,"Speed it up? There's a functor for that."),(0,o.kt)(i.J,{player:P.main,code:T,mdxType:"Player"}),(0,o.kt)("p",null,"Get louder based on the note? There's a functor for that too!"),(0,o.kt)(i.J,{player:A.main,code:I,mdxType:"Player"}),(0,o.kt)("p",null,'The power of functors lies in their ability to "lift" functions from a context to another one. This means that, for example, instead of writing ',(0,o.kt)("inlineCode",{parentName:"p"},"[transpose wholeTone c4, transpose wholeTone d4, transpose wholeTone e4]")," we can write ",(0,o.kt)("inlineCode",{parentName:"p"},"map (transpose wholeTone) [c4, d4, e4]")," and be done with it."),(0,o.kt)("p",null,"We can also partially apply ",(0,o.kt)("inlineCode",{parentName:"p"},"map (transpose wholeTone)")," to create a function that will lift the morphism ",(0,o.kt)("inlineCode",{parentName:"p"},"transpose wholeTone")," to ",(0,o.kt)("em",{parentName:"p"},"any")," functor that has pitches inside of it. In the example below, the functors in question are ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmpty Array")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Cofree Identity"),"."),(0,o.kt)(i.J,{player:J.main,code:B,mdxType:"Player"}),(0,o.kt)("p",null,"One of the most common types of functors is a collection like a ",(0,o.kt)("inlineCode",{parentName:"p"},"List")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"Object")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"Array"),". Insofar as a rhythm is a connection of notes, we can think of functors as lifting functions (morphisms) from individual elements of rhythms to the whole rhythm. What comes out the other end is a new rhythm..."),(0,o.kt)(i.J,{stub:!0,player:p.main,code:l,mdxType:"Player"}),(0,o.kt)("p",null,"...or another rhythm..."),(0,o.kt)(i.J,{stub:!0,player:p.main,code:l,mdxType:"Player"}),(0,o.kt)("p",null,"...or something that most would not call a rhythm but I still find eerily pleasant..."),(0,o.kt)(i.J,{stub:!0,player:p.main,code:l,mdxType:"Player"}),(0,o.kt)("h2",null,"Functor road-show"),(0,o.kt)("p",null,"Let's take functors for a spin! Each of these examples uses ",(0,o.kt)("inlineCode",{parentName:"p"},"map")," is a slightly different way to achieve a slightly different effect."),(0,o.kt)("h3",null,"A"),(0,o.kt)(i.J,{stub:!0,player:p.main,code:l,mdxType:"Player"}),(0,o.kt)("h3",null,"B"),(0,o.kt)(i.J,{stub:!0,player:p.main,code:l,mdxType:"Player"}),(0,o.kt)("h3",null,"C"),(0,o.kt)(i.J,{stub:!0,player:p.main,code:l,mdxType:"Player"}),(0,o.kt)("h2",null,"Applicative functors"),(0,o.kt)("p",null,"Functors in PureScript lift functions (morphisms) from 𝕻 to somewhere else in 𝕻. But what if you want to work with a function that's already been lifted? For example, if we don't have ",(0,o.kt)("inlineCode",{parentName:"p"},"(a -> b)")," but rather we have ",(0,o.kt)("inlineCode",{parentName:"p"},"f (a -> b)"),", can we still use it?"),(0,o.kt)("p",null,"Types that are applicative functors answer with a resounding YES. Applicative functors are exactly like ",(0,o.kt)("inlineCode",{parentName:"p"},"map")," but work on functions that have already been lifted:"),(0,o.kt)("deckgo-highlight-code",{language:"haskell"},"\n          ",(0,o.kt)("code",{parentName:"deckgo-highlight-code",slot:"code"},"class Apply f where\n  apply :: forall a b. f (a -> b) -> (f a -> f b)"),"\n        "),(0,o.kt)("p",null,"The most common use case for applicative functors is partially applied functions, which we saw in several examples from the ",(0,o.kt)("a",{parentName:"p",href:""},"previous article"),"."),(0,o.kt)(i.J,{stub:!0,player:p.main,code:l,mdxType:"Player"}),(0,o.kt)("h2",null,"Indexed functors"),(0,o.kt)("p",null,"In category theory, objects are indivisible. One is not allowed to peek inside of objects to know anything about them. This means that ",(0,o.kt)("inlineCode",{parentName:"p"},"Boolean"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Unit"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Void")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Int")," are all the same in the eyes of a category theorist, and a for a functor to be a functor, it needs to operate indiscriminately on all of these types."),(0,o.kt)("p",null,"However, in 𝕻, this restriction is to severe.  We ",(0,o.kt)("em",{parentName:"p"},"are")," able to reason about certain properties of the inhabitants of objects, aka ",(0,o.kt)("em",{parentName:"p"},"terms"),". For example, we know that the cardinality of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Boolean")," is 2 - ",(0,o.kt)("inlineCode",{parentName:"p"},"true")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"false"),". In addition, certain types are commonly understood to have terms with an inherent ",(0,o.kt)("em",{parentName:"p"},"ordinality"),", meaning that their contents can be indexed by a natural number. This is most apparent in lists, where the first term in a list can be assigned the ordinal number 0, the second term 1, and so forth until the end of the list. It is important to state, however, that these ordinalities are entirely subjective. While ordering the elements of a list ",(0,o.kt)("em",{parentName:"p"},"0,1,2,...,n"),' may feel intuitive, there is nothing axiomatically "correct" about this order. On the other hand, lists verifiably have the cardinality of ',(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Cardinality_of_the_continuum"},"ℵ1"),"."),(0,o.kt)(i.J,{stub:!0,player:p.main,code:l,mdxType:"Player"}),(0,o.kt)("p",null,"Indexed functors are applicative functors that create a lifted function ",(0,o.kt)("inlineCode",{parentName:"p"},"f (a -> b)")," by lifting a function ",(0,o.kt)("inlineCode",{parentName:"p"},"i -> a -> b")," to a ",(0,o.kt)("inlineCode",{parentName:"p"},"f i")," that contains the index ",(0,o.kt)("inlineCode",{parentName:"p"},"i")," in order. While natural numbers is a common index, it is not the only one possible. The full signature is:"),(0,o.kt)("deckgo-highlight-code",{language:"haskell"},"\n          ",(0,o.kt)("code",{parentName:"deckgo-highlight-code",slot:"code"},"class FunctorWithIndex f i | f -> i where\n  mapWithIndex :: (i -> a -> b) -> f a -> f b"),"\n        "),(0,o.kt)("p",null,"The arrow from ",(0,o.kt)("inlineCode",{parentName:"p"},"f")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"i")," in the class signature is called a ",(0,o.kt)("em",{parentName:"p"},"functional dependency")," and indicates that the choice of ",(0,o.kt)("inlineCode",{parentName:"p"},"f")," completely determines ",(0,o.kt)("inlineCode",{parentName:"p"},"i")," or, in other words, that ",(0,o.kt)("inlineCode",{parentName:"p"},"i")," depends (in this case exclusively) on ",(0,o.kt)("inlineCode",{parentName:"p"},"f"),"."),(0,o.kt)(i.J,{stub:!0,player:p.main,code:l,mdxType:"Player"}),(0,o.kt)("p",null,"Indices are crucial in rhythm - they are the signposts that make rhythm come alive. The reason I can talk about JAY-Z delaying the backbeat of beat-2 is because I can reference ",(0,o.kt)("em",{parentName:"p"},"three")," indices: beat-2 (four beats in a measure, so indexed by ",(0,o.kt)("em",{parentName:"p"},"0,1,2,3"),") and backbeat (splitting a beat in two, so indexed ",(0,o.kt)("em",{parentName:"p"},"0,1"),") and the hesitation on the backbeat, meaning how much we are delaying it (indexed by a real number, so ℵ1).  We can use an indexed functor to act on several of these indices at once."),(0,o.kt)(i.J,{stub:!0,player:p.main,code:l,mdxType:"Player"}),(0,o.kt)("h2",null,"Contravariant functors"),(0,o.kt)("p",null,'One great feature of category theory is that you get another category for free by "flipping the arrows". For example, if a catgory ',(0,o.kt)("inlineCode",{parentName:"p"},"X")," has objects ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"B")," and morphisms ",(0,o.kt)("inlineCode",{parentName:"p"},"A -> A"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"B -> B")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"A -> B"),", we get a new category ",(0,o.kt)("inlineCode",{parentName:"p"},"Y")," simply by flipping the arrows, meaning ",(0,o.kt)("inlineCode",{parentName:"p"},"A -> A"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"B -> B")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"B -> A"),". Note that ",(0,o.kt)("inlineCode",{parentName:"p"},"Y")," is purely theoretical: often times, if a category represents a real-world phenomena (ie if ",(0,o.kt)("inlineCode",{parentName:"p"},"->")," is time), we can't flip the arrows and get a time machine for free. But on paper, all categories are flippable, and a large subset of 𝕻 ",(0,o.kt)("em",{parentName:"p"},"is")," in fact flippable (certain important functions, like ",(0,o.kt)("a",{parentName:"p",href:"https://pursuit.purescript.org/packages/purescript-prelude/5.0.1/docs/Data.Void#v:absurd"},(0,o.kt)("inlineCode",{parentName:"a"},"absurd")),", cannot be flipped)."),(0,o.kt)("p",null,"Functors can be applied to these flipped categories and, when they are, they're called ",(0,o.kt)("strong",{parentName:"p"},"contravariant")," functors. ",(0,o.kt)("em",{parentName:"p"},"Contra"),' is used here in its colloquial sense of "in the opposite direction."'),(0,o.kt)("deckgo-highlight-code",{language:"haskell"},"\n          ",(0,o.kt)("code",{parentName:"deckgo-highlight-code",slot:"code"},"class Contravariant f where\n  cmap :: forall a b. (a -> b) -> (f b -> f a)"),"\n        "),(0,o.kt)("p",null,"Note that ",(0,o.kt)("inlineCode",{parentName:"p"},"a")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"b")," are flipped on the right-hand side."),(0,o.kt)("p",null,"Contravariant functors make sense when the object being lifted is the ",(0,o.kt)("em",{parentName:"p"},"input")," to some system. For example, consider the ",(0,o.kt)("inlineCode",{parentName:"p"},"Predicate"),", defined as:"),(0,o.kt)("deckgo-highlight-code",{language:"haskell"},"\n          ",(0,o.kt)("code",{parentName:"deckgo-highlight-code",slot:"code"},"newtype Predicate a = Predicate (a -> Boolean)\nevalPredicate :: forall a. Predicate a -> a -> Boolean\nevalPredicate (Predicate f) a = f a\n-- same as evalPredicate (Predicate f) = f\n-- same as evalPreidcate = coerce"),"\n        "),(0,o.kt)("p",null,"A common predicate is determining if a number is non-negative."),(0,o.kt)("deckgo-highlight-code",{language:"haskell"},"\n          ",(0,o.kt)("code",{parentName:"deckgo-highlight-code",slot:"code"},"nonNegativeNumber = Predicate ((<=) 0.0)"),"\n        "),(0,o.kt)("p",null,"If we want this to apply to integers, we can use ",(0,o.kt)("inlineCode",{parentName:"p"},"cmap")," like so:"),(0,o.kt)("deckgo-highlight-code",{language:"haskell"},"\n          ",(0,o.kt)("code",{parentName:"deckgo-highlight-code",slot:"code"},"-- toNumber :: Int -> Number\nnonNegativeInt = cmap toNumber nonNegativeNumber"),"\n        "),(0,o.kt)("p",null,"Contravariant functors are useful in music when we have a common base operation and we want it to produce a result for different inputs. For example, we can use the same ",(0,o.kt)("inlineCode",{parentName:"p"},"Predicate")," on ",(0,o.kt)("inlineCode",{parentName:"p"},"Pitch"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Duration")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Volume")," by using different versions of ",(0,o.kt)("inlineCode",{parentName:"p"},"cmap"),"."),(0,o.kt)(i.J,{stub:!0,player:p.main,code:l,mdxType:"Player"}),(0,o.kt)("h2",null,"Profunctors"),(0,o.kt)("p",null,"Profunctors are my favorite types of functors. They combine contravariant functors and plain ol' functors in a rather incredible way, and I find that they give the biggest bang for your buck of any concept from functional programming."),(0,o.kt)("p",null,'A pro-functor takes a pair of morphisms - one from an opposite (contravariant) category and one from the "normal" covariant catgory, and maps them to yet-another category. As all we have is 𝕻, this will have to exist entirely within 𝕻, which we can accomplish through a mapping function that takes two morphisms and lifts them to operate on a functor that contains type variabls ',(0,o.kt)("em",{parentName:"p"},"both")," in a contravariant and a covariant position."),(0,o.kt)("deckgo-highlight-code",{language:"haskell"},"\n          ",(0,o.kt)("code",{parentName:"deckgo-highlight-code",slot:"code"},"class Profunctor p where\n  dimap :: forall a b c d. (a -> b) -> (c -> d) -> p b c -> p a d"),"\n        "),(0,o.kt)("p",null,"The most common profunctor you'll come across is the ",(0,o.kt)("inlineCode",{parentName:"p"},"Function"),". Specialized to function, ",(0,o.kt)("inlineCode",{parentName:"p"},"dimap")," becomes ",(0,o.kt)("inlineCode",{parentName:"p"},"(a -> b) -> (c -> d) -> (b -> c) -> (a -> d)"),". This is sort of like spelunking. If you give me a way to get down to the cave ",(0,o.kt)("inlineCode",{parentName:"p"},"a -> b"),", a way to get back up ",(0,o.kt)("inlineCode",{parentName:"p"},"c -> d"),", and some time in the cave ",(0,o.kt)("inlineCode",{parentName:"p"},"b -> c"),", I'll give you back a spelunking trip ",(0,o.kt)("inlineCode",{parentName:"p"},"a -> d"),"."),(0,o.kt)("p",null,"Another metaphor that is more apt for this context is ",(0,o.kt)("em",{parentName:"p"},"editing"),". If you give me a way to zoom into a piece of music ",(0,o.kt)("inlineCode",{parentName:"p"},"a -> b"),", a way to zoom out after you've made a change ",(0,o.kt)("inlineCode",{parentName:"p"},"c -> d"),", and a change ",(0,o.kt)("inlineCode",{parentName:"p"},"b -> c"),", I'll give you a function that changes a piece from ",(0,o.kt)("inlineCode",{parentName:"p"},"a -> d"),". Here, argument order is crucial: if we partially apply dimap in a function ",(0,o.kt)("inlineCode",{parentName:"p"},"editScore = dimap zoomIn zoomOut"),", then ",(0,o.kt)("inlineCode",{parentName:"p"},"editScore")," takes an editing function ",(0,o.kt)("inlineCode",{parentName:"p"},"b -> c")," and returns a function from an old score ",(0,o.kt)("inlineCode",{parentName:"p"},"a")," to a new score ",(0,o.kt)("inlineCode",{parentName:"p"},"d"),". The ideas of zooming in & out are ",(0,o.kt)("em",{parentName:"p"},"visual")," metaphors, and profunctors are often described based on the behavior of light. Other examples are the ",(0,o.kt)("a",{parentName:"p",href:""},(0,o.kt)("inlineCode",{parentName:"a"},"Optic")),", the ",(0,o.kt)("a",{parentName:"p",href:""},(0,o.kt)("inlineCode",{parentName:"a"},"Lens"))," and the ",(0,o.kt)("a",{parentName:"p",href:""},(0,o.kt)("inlineCode",{parentName:"a"},"Prism")),". The zooming I've just described is in fact a ",(0,o.kt)("inlineCode",{parentName:"p"},"Lens"),", and there are two resources I know of that cover profunctor optics exhaustively:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"A"),(0,o.kt)("li",{parentName:"ul"},"B")),(0,o.kt)("p",null,"All of the setters in the ",(0,o.kt)("inlineCode",{parentName:"p"},"wags-lib")," library are profunctors. They are the stuff music is made of. In the following example, we use eight different profunctor lenses:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"A"),(0,o.kt)("li",{parentName:"ol"},"A"),(0,o.kt)("li",{parentName:"ol"},"A"),(0,o.kt)("li",{parentName:"ol"},"A"),(0,o.kt)("li",{parentName:"ol"},"A"),(0,o.kt)("li",{parentName:"ol"},"A"),(0,o.kt)("li",{parentName:"ol"},"A"),(0,o.kt)("li",{parentName:"ol"},"A")),(0,o.kt)(i.J,{stub:!0,player:p.main,code:l,mdxType:"Player"}),(0,o.kt)("p",null,"We can even make our own - here is a different example with two hand-rolled lenses to modulate X and Y."),(0,o.kt)(i.J,{stub:!0,player:p.main,code:l,mdxType:"Player"}),(0,o.kt)("p",null,"Profunctors are when things get interesting: they can zoom into data structures with arbitrary levels of precision (contravariant) and come back out (covariant). Going back to the definition of rhythm as a subtle dance of symmetries and asymmetries in accents over time, profunctors take something bland..."),(0,o.kt)(i.J,{stub:!0,player:p.main,code:l,mdxType:"Player"}),(0,o.kt)("p",null,"...and shape it so that it has ",(0,o.kt)("em",{parentName:"p"},"rhythm"),"!"),(0,o.kt)(i.J,{stub:!0,player:p.main,code:l,mdxType:"Player"}),(0,o.kt)("h2",null,"On the functorality of rhythms and the rhythm of functors"),(0,o.kt)("p",null,"In this article, we looked at five different variations on the theme of the functor:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Covariant functor"),(0,o.kt)("li",{parentName:"ul"},"Applicative functor"),(0,o.kt)("li",{parentName:"ul"},"Indexed functor"),(0,o.kt)("li",{parentName:"ul"},"Contravariant functor"),(0,o.kt)("li",{parentName:"ul"},"Profunctor")),(0,o.kt)("p",null,"We heard musical examples of how all five can drive a rhythm. At the risk of being gaudy, here's an example of all five shaping a piece of music."),(0,o.kt)(i.J,{stub:!0,player:p.main,code:l,mdxType:"Player"}),(0,o.kt)("p",null,"Rhythms are functors because they map musical events like notes to a new place where the events have (a) order and (b) variety (dynamic, agogic, harmonic etc). But do functors have a rhythm? Functors map object to new places like ",(0,o.kt)("inlineCode",{parentName:"p"},"Int")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"Maybe Int"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Boolean")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"List Boolean"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"String")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"Event String")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Number")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"Tuple Unit Number"),". What the objects become in these new contexts are anyone's guess. In ",(0,o.kt)("inlineCode",{parentName:"p"},"Maybe Int")," the existence of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Int")," becomes optional, in ",(0,o.kt)("inlineCode",{parentName:"p"},"List Boolean")," the existence of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Boolean")," becomes multiple, in ",(0,o.kt)("inlineCode",{parentName:"p"},"Event String")," the existence of the ",(0,o.kt)("inlineCode",{parentName:"p"},"String")," becomes both multiple and temporal and in ",(0,o.kt)("inlineCode",{parentName:"p"},"Tuple Unit Number")," the existence of ",(0,o.kt)("inlineCode",{parentName:"p"},"Number")," remains singular but it gets a buddy ",(0,o.kt)("inlineCode",{parentName:"p"},"Unit"),". The elusive and wide-raning nature of the little bit of flair that functors can add is as rich, subtle, and surprising as the numerous ways a note can be accented. A note can disappear altogether (rest), be muted (con sordino), be delayed (rubato), or be played several times in rapid succession (tremolo). In this way, functors act as the accents of categories."),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Functor"),(0,o.kt)("th",{parentName:"tr",align:null},"Agogic"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Proxy"),(0,o.kt)("td",{parentName:"tr",align:null},"rest")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Behavior"),(0,o.kt)("td",{parentName:"tr",align:null},"drone")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Vec D3"),(0,o.kt)("td",{parentName:"tr",align:null},"triad")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Tuple Percussion"),(0,o.kt)("td",{parentName:"tr",align:null},"orchestration")))),(0,o.kt)("p",null,"But what about order? For functors to have rhythm, it is not enough that they add accents to a catgory. They must also create some type of order."),(0,o.kt)("p",null,"Morphisms in categories can be thought of as ",(0,o.kt)("em",{parentName:"p"},"ordering")," the category. In 𝕻, for example, ",(0,o.kt)("inlineCode",{parentName:"p"},"->")," implies a before-after relationship between types. A function must receive its input ",(0,o.kt)("em",{parentName:"p"},"before")," yielding its output."),(0,o.kt)("p",null,"A functor cannot reorder its source category because it must preserve morphisms. However, nothing stops a functor from conflating many morphisms into the same one (and, by extention, many objects to the same object). The extreme example of this is ",(0,o.kt)("inlineCode",{parentName:"p"},"Proxy"),", which maps all objects a single object and all morphisms to a single morphism."),(0,o.kt)("p",null,"𝕻 is an unfathomably rich source category - it conains arrows from all terms to all other terms ",(0,o.kt)("em",{parentName:"p"},"except")," in the case where the source is inhabited and the destination is not. Meaning that you won't find anything of the signature ",(0,o.kt)("inlineCode",{parentName:"p"},"a -> Void")," unless ",(0,o.kt)("inlineCode",{parentName:"p"},"a")," itself is uninhabited. These functions are rare and are almost exclusively used when proving something to a compiler via ",(0,o.kt)("a",{parentName:"p",href:"https://docs.idris-lang.org/en/latest/tutorial/theorems.html#the-empty-type"},"proof by contradiction"),". This means that a functor has at its disposal infintely many connections and can reduc them to its own special order, much like a sculptor starts from slab of marble with limitless possibilities and arrives at a beautifully-proportioned work of art."),(0,o.kt)("p",null,"By assigning an accent (a quality or mood) to a type and by pruning the vast, order-rich 𝕻 to something with a more slimmed-down order (including no order at all), when we apply functors, we are breathing rhythm into types. So rhythms are not just functors - functors are rhythms. They both transport us to new places, and some of my greatest joys in life come when a new functor or rhythm transports me to an entirely new place that I would have never imagined before."),(0,o.kt)(i.J,{stub:!0,player:p.main,code:l,mdxType:"Player"}),(0,o.kt)(r.Z,{mdxType:"Footer"}))}M.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-rhythm-functor-mdx-70568b234b5169dae7e3.js.map